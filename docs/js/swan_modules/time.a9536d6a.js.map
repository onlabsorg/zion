{"version":3,"sources":["webpack:///./node_modules/@onlabsorg/swan-js/lib/modules/time.js"],"names":["module","exports","types","time","isNumb","x","wrap","Numb","isText","Text","isNamespace","Namespace","undefined_text","Undefined","undefined_date","now","Date","timezone","getTimezoneOffset","to_date","t","date","year","getFullYear","month","getMonth","day","getDate","hours","getHours","minutes","getMinutes","seconds","getSeconds","getMilliseconds","to_UTC_date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","from_date","NaN","Math","trunc","milliseconds","round","Number","from_UTC_date","UTC","to_ISO_string","toISOString","from_string","s","parse","week_day","getDay","week_number","setHours","setDate","week1","getTime"],"mappings":"oGAaAA,EAAOC,QAAUC,IACb,MAAMC,EAAO,GAEPC,EAASC,GAAKH,EAAMI,KAAKD,aAAcH,EAAMK,KAC7CC,EAASH,GAAKH,EAAMI,KAAKD,aAAcH,EAAMO,KAC7CC,EAAcL,GAAKH,EAAMI,KAAKD,aAAcH,EAAMS,UAElDC,EAAiB,IAAIV,EAAMW,UAAU,QACrCC,EAAiB,IAAIZ,EAAMW,UAAU,QAuL3C,OA/KAV,EAAKY,IAAM,IAAMC,KAAKD,MAAQ,IAS9BZ,EAAKc,SAAW,MAAO,IAAKD,MAAQE,oBAAsB,GAgB1Df,EAAKgB,QAAUC,IACX,IAAKhB,EAAOgB,GAAI,OAAON,EACvB,MAAMO,EAAO,IAAIL,KAAO,IAAFI,GACtB,MAAO,CACHE,KAAMD,EAAKE,cACXC,MAAOH,EAAKI,WAAa,EACzBC,IAAKL,EAAKM,UACVC,MAAOP,EAAKQ,WACZC,QAAST,EAAKU,aACdC,QAASX,EAAKY,aAAeZ,EAAKa,kBAAoB,MAkB9D/B,EAAKgC,YAAcf,IACf,IAAKhB,EAAOgB,GAAI,OAAON,EACvB,MAAMO,EAAO,IAAIL,KAAO,IAAFI,GACtB,MAAO,CACHE,KAAMD,EAAKe,iBACXZ,MAAOH,EAAKgB,cAAgB,EAC5BX,IAAKL,EAAKiB,aACVV,MAAOP,EAAKkB,cACZT,QAAST,EAAKmB,gBACdR,QAASX,EAAKoB,gBAAkBpB,EAAKqB,qBAAuB,MAWpEvC,EAAKwC,UAAYtB,IACb,IAAKX,EAAYW,GAAO,OAAOuB,IAC/B,MAAMZ,EAAUX,EAAKW,QAAUa,KAAKC,MAAMzB,EAAKW,SAAW,EACpDe,EAAeF,KAAKG,MAAiC,KAA1B3B,EAAKW,QAAUA,IAChD,OAAOiB,OAAO,IAAIjC,KACdK,EAAKC,MAAQ,GACZD,EAAKG,OAAS,GAAK,EACpBH,EAAKK,KAAO,EACZL,EAAKO,OAAS,EACdP,EAAKS,SAAW,EAChBE,EACAe,IACC,KAUT5C,EAAK+C,cAAgB7B,IACjB,IAAKX,EAAYW,GAAO,OAAOuB,IAC/B,MAAMZ,EAAUX,EAAKW,QAAUa,KAAKC,MAAMzB,EAAKW,SAAW,EACpDe,EAAeF,KAAKG,MAAiC,KAA1B3B,EAAKW,QAAUA,IAChD,OAAOiB,OAAOjC,KAAKmC,IACf9B,EAAKC,MAAQ,GACZD,EAAKG,OAAS,GAAK,EACpBH,EAAKK,KAAO,EACZL,EAAKO,OAAS,EACdP,EAAKS,SAAW,EAChBE,EACAe,IACC,KAeT5C,EAAKiD,cAAgBhC,GAAKhB,EAAOgB,GAAK,IAAIJ,KAAO,IAAFI,GAAQiC,cAAgBzC,EAcvET,EAAKmD,YAAcC,GAAK/C,EAAO+C,GAAKN,OAAQjC,KAAKwC,MAAMD,IAAO,IAAOX,IAcrEzC,EAAKsD,SAAWrC,GAAKhB,EAAOgB,GAAK,IAAIJ,KAAO,IAAFI,GAAQsC,SAAWd,IAa7DzC,EAAKwD,YAAcvC,IACf,IAAKhB,EAAOgB,GAAI,OAAOwB,IACvB,MAAMvB,EAAO,IAAIL,KAAO,IAAFI,GACtBC,EAAKuC,SAAS,EAAG,EAAG,EAAG,GAEvBvC,EAAKwC,QAAQxC,EAAKM,UAAY,GAAKN,EAAKqC,SAAW,GAAK,GAExD,IAAII,EAAQ,IAAI9C,KAAKK,EAAKE,cAAe,EAAG,GAE5C,OAAO,EAAIsB,KAAKG,QAAQ3B,EAAK0C,UAAYD,EAAMC,WAAa,MAAW,GAAKD,EAAMJ,SAAW,GAAK,GAAK,IAIpGvD","file":"js/swan_modules/time.a9536d6a.js","sourcesContent":["/**\n *  time module\n *  ============================================================================\n *  \n *  This module contains functions and constants that operate on time and\n *  dates.\n *  \n *  Unless specified otherwise, all the functions of this library assume that\n *  their parameter is an item (1-d tuple). If more that one item is passed\n *  to a function, only the first item will be used and the others will be\n *  ignored.\n */\n\nmodule.exports = types => {\n    const time = {};\n    \n    const isNumb = x => types.wrap(x) instanceof types.Numb;\n    const isText = x => types.wrap(x) instanceof types.Text;\n    const isNamespace = x => types.wrap(x) instanceof types.Namespace;\n    \n    const undefined_text = new types.Undefined(\"Text\");\n    const undefined_date = new types.Undefined(\"Date\");\n\n\n    /**\n     *  time.now: () => Numb t\n     *  ------------------------------------------------------------------------\n     *  It returns the current epoch time in seconds.\n     */\n    time.now = () => Date.now() / 1000;\n\n\n    /**\n     *  time.timezone: () -> Numb n\n     *  ------------------------------------------------------------------------\n     *  It returns the current UTC time-zone offset in hours. For example in \n     *  UTC+1 it will return +1.\n     */\n    time.timezone = () => -(new Date()).getTimezoneOffset() / 60;\n    \n    \n    /**\n     *  time.to_date: Numb t -> Namespace d\n     *  ------------------------------------------------------------------------\n     *  Given an epoch time expressed in seconds, it returns a `date` Namespace \n     *  containg the following local date information:\n     *  \n     *  - `date.year` : Numb\n     *  - `date.month` : Numb between 1 (January) and 12 (December)\n     *  - `date.day` : Numb between 1 and 31\n     *  - `date.hours` : Numb between 0 and 23\n     *  - `date.minutes` : Numb between 0 and 59\n     *  - `date.seconds` : Numb between 0.000 and 59.999\n     */\n    time.to_date = t => {\n        if (!isNumb(t)) return undefined_date;\n        const date = new Date(t*1000);\n        return {\n            year: date.getFullYear(),\n            month: date.getMonth() + 1,\n            day: date.getDate(),\n            hours: date.getHours(),\n            minutes: date.getMinutes(),\n            seconds: date.getSeconds() + date.getMilliseconds() / 1000,\n        }\n    }\n\n    \n    /**\n     *  time.to_UTC_date: Numb t -> Namespace d\n     *  ------------------------------------------------------------------------\n     *  Given an epoch time expressed in seconds, it returns a `date` Namespace \n     *  containg the following UTC date information:\n     *  \n     *  - `date.year` : Numb\n     *  - `date.month` : Numb between 1 (January) and 12 (December)\n     *  - `date.day` : Numb between 1 and 31\n     *  - `date.hours` : Numb between 0 and 23\n     *  - `date.minutes` : Numb between 0 and 59\n     *  - `date.seconds` : Numb between 0.000 and 59.999\n     */\n    time.to_UTC_date = t => {\n        if (!isNumb(t)) return undefined_date;\n        const date = new Date(t*1000);\n        return {\n            year: date.getUTCFullYear(),\n            month: date.getUTCMonth() + 1,\n            day: date.getUTCDate(),\n            hours: date.getUTCHours(),\n            minutes: date.getUTCMinutes(),\n            seconds: date.getUTCSeconds() + date.getUTCMilliseconds() / 1000,\n        }\n    },\n    \n\n    /**\n     *  time.from_date: Namespace d -> Numb t\n     *  ------------------------------------------------------------------------\n     *  Given a local date namespace, it returns the correspondign epoch time \n     *  expressed in seconds.\n     */\n    time.from_date = date => {\n        if (!isNamespace(date)) return NaN;\n        const seconds = date.seconds ? Math.trunc(date.seconds) : 0;\n        const milliseconds = Math.round((date.seconds - seconds) * 1000);\n        return Number(new Date(\n            date.year || 0,\n            (date.month || 1) - 1,\n            date.day || 1,\n            date.hours || 0,\n            date.minutes || 0,\n            seconds,\n            milliseconds\n        )) / 1000;\n    },\n\n    \n    /**\n     *  time.from_UTC_date: Namespace d -> Numb t\n     *  ------------------------------------------------------------------------\n     *  Given an UTC date namespace, it returns the correspondign epoch time \n     *  expressed in seconds.\n     */\n    time.from_UTC_date = date => {\n        if (!isNamespace(date)) return NaN;\n        const seconds = date.seconds ? Math.trunc(date.seconds) : 0;\n        const milliseconds = Math.round((date.seconds - seconds) * 1000);\n        return Number(Date.UTC(\n            date.year || 0,\n            (date.month || 1) - 1,\n            date.day || 1,\n            date.hours || 0,\n            date.minutes || 0,\n            seconds,\n            milliseconds\n        )) / 1000;\n    },\n\n\n    /**\n     *  time.to_ISO_string: Numb t -> Text d\n     *  ------------------------------------------------------------------------\n     *  Given an epoch time in seconds, it returns its ISO string representation.\n     *  For example:\n     *  \n     *  ```\n     *  time = time.to_ISO_string(1639513675.900)\n     *  // returns \"2021-12-14T20:27:55.900Z\"\n     *  ```\n     */\n    time.to_ISO_string = t => isNumb(t) ? new Date(t*1000).toISOString() : undefined_text;\n    \n\n    /**\n     *  time.from_string: Text d -> Numb t\n     *  ------------------------------------------------------------------------\n     *  Returns an epoch time in seconds given a date string representation.\n     *  For example:\n     *  \n     *  ```\n     *  time = time.from_string(\"2021-12-14T20:27:55.900Z\")   \n     *  // returns 1639513675.900 s\n     *  ```\n     */\n    time.from_string = s => isText(s) ? Number( Date.parse(s) ) / 1000 : NaN;\n    \n\n    /**\n     *  time.week_day: Numb t -> Numb wd\n     *  ------------------------------------------------------------------------\n     *  Given an epoch time, it returns the day of the week of the corresponding, \n     *  date in the loacal timezone. Sunday is 0, monday is 1, tuesday is 2, etc.\n     *  For example:\n     *  \n     *  ```\n     *  time.week_day(1639513675.900)   // returns 2 for Tuesday\n     *  ```\n     */\n    time.week_day = t => isNumb(t) ? new Date(t*1000).getDay() : NaN;\n    \n\n    /**\n     *  time.week_number: Numb t -> Numb w\n     *  ------------------------------------------------------------------------\n     *  Given an epoch time, it returns the week number of the corresponding, \n     *  date in the loacal timezone. For example:\n     *  \n     *  ```\n     *  time.week_number(1639513675.900)   // returns 50\n     *  ```\n     */\n    time.week_number = t => {\n        if (!isNumb(t)) return NaN;\n        const date = new Date(t*1000);\n        date.setHours(0, 0, 0, 0);\n        // Thursday in current week decides the year.\n        date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);\n        // January 4 is always in week 1.\n        var week1 = new Date(date.getFullYear(), 0, 4);\n        // Adjust to Thursday in week 1 and count number of weeks from date to week1.\n        return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);        \n    };\n    \n    \n    return time;  \n}\n\n"],"sourceRoot":""}